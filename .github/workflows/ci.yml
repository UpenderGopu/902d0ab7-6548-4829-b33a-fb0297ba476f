# ============================================================================
# ci.yml - GitHub Actions CI/CD Pipeline
# This workflow automatically runs on every push/PR to the main branch.
# Job 1 (build-and-test): Builds the .NET project, runs unit tests, and
#   uploads code coverage reports.
# Job 2 (docker): Builds a Docker image and pushes it to GitHub Container
#   Registry (ghcr.io). Only runs after Job 1 succeeds.
# ============================================================================
name: CI

on:
  push:
    branches: [main]  # This Trigger the workflow on push to main branch
  pull_request:
    branches: [main]  # This Trigger the workflow on pull request to main branch

jobs:
  build-and-test:  # This is the name of the job and this is Job 1
    runs-on: ubuntu-latest  # GitHub creates the new ubuntu virtual machine in the cloud and runs the job on it

    steps:
      - uses: actions/checkout@v4  # GitHub downloads code from the repository into this virtual machine. Now the VM has all files

      - name: Setup .NET
        uses: actions/setup-dotnet@v4  # This Downloads and installs the .NET 8.0 SDK on the VM.
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore  # This downloads all the NuGet packages project needs (like EntityFramework, xUnit, etc.)

      - name: Build
        run: dotnet build --no-restore -c Release  # This compiles C# code into an executable DLL file (LIS.dll and LIS.Tests.dll).

      - name: Test
        run: dotnet test --no-build -c Release --verbosity normal --collect:"XPlat Code Coverage"  # This runs all unit tests in the project. It checks if the code behaves as expected.

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: '**/coverage.cobertura.xml'  # This uploads the coverage report to GitHub Actions.

  docker:  # This is the name of the job and this is Job 2 (runs ONLY after Job 1 succeeds)
    runs-on: ubuntu-latest
    needs: build-and-test  # This job depends on the build-and-test job, "Don't even start this job unless Job 1 succeeds"
    permissions:  # This specifies the permissions required for the job
      packages: write
      contents: read

    steps:
      - uses: actions/checkout@v4  

      - name: Log in to GitHub Container Registry   # Logs into ghcr.io (GitHub's Docker image storage) using your automatic GitHub token. This is like logging into Docker Hub, but it's GitHub's own registry. No setup needed â€” GitHub provides the token automatically.
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Set lowercase repo name
        run: echo "REPO_LC=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Build Docker image   # Builds the Docker image using the Dockerfile in the root directory. The -t flag tags the image with the repository name and :latest tag.
        run: docker build -t ghcr.io/${{ env.REPO_LC }}:latest .

      - name: Push Docker image   # Uploads the built image to GitHub Container Registry (ghcr.io). Now it's available for anyone with access to pull and run.
        run: docker push ghcr.io/${{ env.REPO_LC }}:latest
